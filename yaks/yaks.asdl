# yaks - idea to rewrite mycpp.
# 
# MAYBE:
# - Can we generate value types in C++, to reduce GC pressure?  Is that done
#   with a new ASDL keyword?
#
# The Yaks IR can be generated from:
# 1. typed Python 2, like mycpp.  This can be done with the Python 3.8 AST,
#    like pea/
#    - we have a speed test of parsing in parallel in 300 ms or so
#
# Much later:
#
# 1. Some kind of Tea/ typed YSH syntax?  To write builtins in YSH, with typed
#   'case' syntax?
#   - better context manager / constructor-destructor syntax?
#   - value types?
#   - but there is no syntax for data types in YSH.
#     - I think those are DYNAMIC SCHEMAS
#     - We can keep ASDL though.
# 2. If mycpp has a universal string type, and maybe double support:
#    - TypeScript/JavaScript.  See oilshell/yaks experiment.
#    - Python 3 with unicode string/byte semantics
#      - we have a supported interpreter and tooling
#    - Universal string type would use the PyPy utf-8 and utf-16 indices:
#    64-byte blocks.
#
# Sketch of compilation pipeline:
# 1. Create a CST language that can be hand-written or generated
# 2. It can be transformed to this yaks.asdl, in the style of
#    oilshell/yaks/transform.ts Precedence is unambiguous (+ 1 2)
# 3. Go through the stages in mycpp/README.md, but PER MODULE
#    a. const pass for GLOBAL_STR -- immutable literals
#    b. forward decl pass
#    c. declaration/function prototype pass
#       - GC Masks are generated from this typed IR.  It knows about pointers
#       and so forth
#    d. implementation pass
# 4. Then all the C++ goes into Ninja, as usual.

# TODO: where do we put location info?  For the type checker to blame.  I think
# it's on every CST node?
# I guess it's all the Call() nodes then?

module yaks
{
  # path is for error messages
  # We may also map from path -> newline locations, for printing lines and
  # columns
  Token = (str path, str chunk, int start, int length)

  Bool = (bool b, Token loc)  # true false
  Int = (int i, Token loc)  # 42
  Str = (str s, Token loc)  # "\n"

  # ''' strings like YSH, for embedding say re2c blocks?
  # strip leading whitespace
  MultiStr = (List[Token] lines)

  #
  # Heterogeneous Tree - make illegal states unrepresentable (compared to
  # homogeneous tree)
  #

  op =
    Plus
  | Minus

  kexpr =
    Bool %Bool
  | Int %Int
  | Str %Str
  | MultiStr %MultiStr

    # e.g. (not true)
  | Unary(Token op, kexpr child)
    # e.g. (+ 1 2)
    #      (a i)  is a[i]
    #      (d key)  is d[key]
  | Binary(Token op, kexpr left, kexpr right)

    # 'x' if mybool else 'y'
  | Ternary(Token op, kexpr left, kexpr cond, kexpr right)

    # List[Int] is (List Int) I guess
    # This means we don't confuse Python and C++ precedence?  Everything is
    # parenthesized.
  | Call(kexpr f, List[kexpr] args)

  # Avoid conflict with hnode_asdl.Field (TODO: should have namespaces)
  Field_ = (str name, ktype typ)

  # Do we have first-class / shared variants in this language?  We need it for
  # Oils, not sure about Yaks itself.
  variant = (Field_* fields)

  # Is this representation type checked directly?  I guess that would help.
  # But Pea is also type checked?
  ktype =
    Bool
  | Int
  | Str
  | List(ktype T)
  | Dict(ktype K, ktype V)

    # How do we reference the symbol table?
  | Class(str name)

    # This is like ASDL.  Or do we do type checking on CLASSES only, and this
    # is SUGAR?
  | Data(Field_* fields)
  | Enum(variant* variants)

  NameType = (str name, ktype typ)

  stmt =
    VarDecl(Token keyword)        # (var i Int 42)  =>  int i = 42;
  | PlaceMutation(Token keyword)  # (setvar x y)    =>  x = y;

  | If()
  | Switch()  # generated by 'with tagswitch'
  | For()
  | While()

  | Break
  | Continue
  | Return(kexpr e)

    # LATER
  | Try()
  | With()  # Scoped destruction

  # definitions allowed in a class
  class_def = 
    Constructor()
  | Destructor()  # context managers generate this
  | Method()
  | Field()

  Signature = (List[NameType] params, ktype return_type)
  # definitions allowed in a module
  mod_def =
    # These are different because we know the size at compile time.
    # GLOBAL_STR()  GLOBAL_LIST()  GLOBAL_DICT()
    #
    # There's also the idea of taking an entire parsed ASDL structure and
    # making it a global!
    # I guess if you have these 3, it's not that hard.  You just need
    # GLOBAL_CLASS(MyClass, {...}).  It will probably bloat the binary
    # considerably, but could be the best solution.
    Global(NameType name_type)  # GLOBAL_STR

  | Func(str name, Signature sig, List[stmt] statements)
    # what we're generating
  | Class(str name, List[class_def] defs)

    # Python import
  | Import()

    # include <stdio.h>
    # also need names to type check?  we may need the equivalent of .pyi files
    # how do we express this in Python, maybe some special comments?
  | Include(str path)

    # Is this SUGAR on top of classes?
  | Data()
  | Enum()


  # This is list of globals, class/method definitions, and functions.
  # It has DEPS (to be worked out)
  # (module "core/runtime_asdl" (data ...)
  Module = (str name, List[mod_def] defs)

  # A program is a collection of modules to link together, along with a main
  # module like oils_for_unix, in bin/oils_for_unix.py.
  # 
  # It contains a main function like oils_for_unix::main().
  #
  # TODO: do we need any notion of package, like osh/ and core/ ?

  Program = (str main_module, List[Module] modules)
}

# vim: sw=2

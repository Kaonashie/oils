#!/usr/bin/env ysh
# vim:foldmethod=marker

module stdlib/synch || return 0

# General utilities for fds {{{

# Get fdInfo, returns null if fd doesn't exist
proc get-fd-info(; fd, out_fd_info) {
  call out_fd_info->setValue($(cat /proc/$BASHPID/fdinfo/$fd))
}

proc get-fd-flag(; fd, out_fd_flag) {
  get-fd-info (fd, &fd_info)
  if (fd_info ~ / 'flags:' \t <capture digit+> /) {
    call out_fd_flag->setValue(_match(1))
  } else {
    echo "Can't find flags in fdinfo:"
    echo $fd_info
    exit 1
  }
}

# O_RDONLY (00), O_WRONLY (01) & O_RDWR (02) 
func isFdRead(fd) {
  # HACK: this take one octal number direct from the number string,
  # since currently there's no way to convert number bits in std.
  get-fd-flag (fd, &fd_flag)
  return (fd_flag[-1] === "0" or fd_flag[-1] === "2" )
}

func isFdWrite (fd) {
  get-fd-flag (fd, &fd_flag)
  return (fd_flag[-1] === "1" or fd_flag[-1] === "2")
}

proc fd-destroy(; fd) {
  var fd_info = ""
  try {
    get-fd-info (fd, &fd_info)
  }
  if (_status === 0) {
    var fifoFile = $(readlink "/proc/$BASHPID/fd/$fd")
    # NOTE: No need to close both end of a pipe.
    exec {fd}>&-
    rm $fifoFile
  } else {
    echo "Double Destroying the fd $fd twice!" 1>&2
    exit 1
  }
}
# }}}
# FIFO File Descriptors {{{

proc fifo-fd-new(; out_fd) {
  # WARN: this section should be critical but for now it's not
  # A solution may be retry on fail.
  #====================
  var fifo = $(mktemp -u)
  mkfifo $fifo
  #====================
  exec {fd}<>$fifo
  call out_fd->setValue(fd)
}

proc fifo-fd-destroy (; fd) {
  fd-destroy (fd)
}

# }}}
# Semaphores {{{

proc sema-new(; value, out_sema) {
  fifo-fd-new (&sema)
  sema-up (sema, value)
  call out_sema->setValue(sema)
}

proc sema-down(; sema) {
  read <&$sema
}

proc sema-up(; sema, delta = 1) {
  fork {
    for _ in (0 .. delta) {
      echo >&$sema
    }
  }
}

proc sema-destroy(; sema) {
  fifo-fd-destroy (sema)
}

# }}}
# Mutex {{{

proc mutex-new(; out_mutex) {
  sema-new (1, out_mutex)
} 

proc mutex-acquire(; mutex) {
  sema-down (mutex)
}

proc mutex-release(; mutex) {
  sema-up (mutex)
}

proc mutex-destroy(; mutex) {
  sema-destroy (mutex)
}

# }}}
# Channels {{{
# - Pipeline but you can send multiple objects across pipelines
# - Has to manually ensure the number of sent/received blocks are same across each side.
# - Blocks, no buffering
# - Backed by a modified net-string implementation

const ZERO_CHAR = u'\u{0}'

proc channel-new(; out_chan) {
  mutex-new (&write_lock)
  mutex-new (&read_lock)
  fifo-fd-new (&pipe)
  call out_chan->setValue({
    write_lock,
    read_lock,
    pipe,
  })
}

# NOTE: I would love to optimize this a bit more, for example netstring of size n 
# now takes log_10(n) over head. We can certainly do this better by byte encoding
# It would be log_128(n) (using 1 bit for indicating the number ends)
# That's a ln 128 / ln 10 which is roughly twice less overhead.
proc channel-in(; chan) {
  var msg = $(cat) # consume everything from input
  var msg_len = len(msg)
  mutex-acquire (chan.write_lock)
  write -n ${msg_len}${ZERO_CHAR}${msg} >&$[chan.pipe]
  mutex-release (chan.write_lock)
}

proc channel-out(; chan) {
  var msg_len = ""
  mutex-acquire (chan.read_lock)
  while (true) {
    read -n 1 next_char <&$[chan.pipe]
    if (next_char !== ZERO_CHAR) {
      setvar msg_len = msg_len ++ next_char
    } else {
      break
    }
  }
  read -n $msg_len chunk <&$[chan.pipe]
  write -n $chunk
  mutex-release (chan.read_lock)
}

proc channel-destroy(; chan) {
  # Ensures no one else is working
  mutex-acquire (chan.read_lock)
  mutex-acquire (chan.write_lock)
  # Clean up
  fifo-fd-destroy (chan.pipe)
  mutex-destroy (chan.write_lock)
  mutex-destroy (chan.read_lock)
}

# }}}
# RWLock {{{

proc rw-lock-new(; out_lock) {
  var lockfile = $(mktemp)
  var lock = {
    fd: null,
    lockfile,
  }
  call out_lock->setValue(lock)
}

proc rw-lock-read-out(; lock) {
  if (isFdRead(lock.fd)) {
    # TODO: ensure lock is held with correct permission
    cat $[lock.lockfile]
  } else {
    echo "No rwlock held at $[lock.fd]" 1>&2
    exit 1
  }
}

proc rw-lock-write-in(; lock) {
  if (isFdWrite(lock.fd)) {
    # TODO: ensure lock is held with correct permission
    cat > $[lock.lockfile]
  } else {
    echo "No exclusive lock held at rwlock $[lock.fd]" 1>&2
    exit 1
  }
}

# NOTE: to change the type of a lock to T, e.g. from shared to exclusive, just call rw-lock-{T} again. 
proc rw-lock-shared(; lock) {
  exec {lock_fd}<$[lock.lockfile]
  setvar lock.fd = lock_fd
  flock -s $[lock.fd]
}

proc rw-lock-exclusive(; lock) {
  exec {lock_fd}<>$[lock.lockfile]
  setvar lock.fd = lock_fd
  flock -x $[lock.fd]
}

proc rw-unlock(; lock) {
  try {
    get-fd-info (lock.fd, &lock_fd_info)
  }
  if (_status === 0) {
    var lock_fd = lock.fd
    flock -u $lock_fd
    exec {lock_fd}<&-
  } else {
    echo "No rwlock held at $[lock.fd]" 1>&2
    exit 1
  }
}

proc rw-lock-destroy(; lock) {
  rw-lock-exclusive (lock)
  fd-destroy (lock.fd)
}

proc rw-lock-swap-fn(; lock, fn) {
  rw-lock-exclusive (lock)
  var swapped = $(rw-lock-read-out (lock)) => fn()
  write -n $swapped | rw-lock-write-in (lock)
  rw-unlock (lock)
}

# TODO: Performs an lock-guarded write on a lock's file
# The issue is we need to know when to close the pipe
# proc rw-lock-swap-pipe(; lock)

# }}}
# Exhaustable Channels {{{
# Channels but exhaustable

proc exh-channel-new(; out_chan) {
  mutex-new (&write_lock)
  mutex-new (&read_lock)
  fifo-fd-new (&pipe)
  # a counter on how many information we have on the pipe
  rw-lock-new (&message_count)
  # a lock indicating if there's upcoming writes
  rw-lock-new (&will_write)
  rw-lock-exclusive (message_count)
  write -n 0 | rw-lock-write-in (message_count)
  rw-unlock (message_count)
  call out_chan->setValue({
    write_lock,
    read_lock,
    pipe,
    message_count,
    will_write,
  })
}

func __synch_exh_channel_inc_untyped (buf) {
  var typed = buf => int()
  var swapped = typed + 1
  var untyped = "$[swapped]"
  return (untyped)
}

proc exh-channel-in(; chan) {
  var msg = $(cat) # consume everything from input
  var msg_len = len(msg)
  rw-lock-swap-fn (chan.message_count, __synch_exh_channel_inc_untyped)
  rw-lock-shared (chan.will_write)
  mutex-acquire (chan.write_lock)
  write -n $msg_len$ZERO_CHAR$msg >&$[chan.pipe]
  mutex-release (chan.write_lock)
  rw-unlock (chan.will_write)
}

proc __exh_channel_out_no_lock(; chan) {
  var msg_len = ""
  while (true) {
    read -n 1 next_char <&$[chan.pipe]
    if (next_char !== ZERO_CHAR) {
      setvar msg_len = msg_len ++ next_char
    } else {
      break
    }
  }
  read -n $msg_len chunk <&$[chan.pipe]
  write -n $chunk
}

proc exh-channel-out(; chan) {
  mutex-acquire (chan.read_lock)
  __exh_channel_out_no_lock (chan)
  mutex-release (chan.read_lock)
}

proc exh-channel-exhaust(; chan, out_ret) {
  # No body should send anything to the channel from now on
  rw-lock-exclusive (chan.will_write)
  # Count how many message we have
  rw-lock-exclusive (chan.message_count)
  rw-lock-read-out (chan.message_count) | json read (&num_msg)
  write -n 0 | rw-lock-write-in (chan.message_count)
  rw-unlock (chan.message_count)

  var ret = []
  mutex-acquire (chan.read_lock)
  for _ in (0..num_msg) {
    call ret->append($(__exh_channel_out_no_lock (chan)))
  }
  mutex-release (chan.read_lock)
  rw-unlock (chan.will_write)
  call out_ret->setValue(ret)
}

proc exh-channel-destroy(; chan) {
  # Ensures no one else is working
  mutex-acquire (chan.read_lock)
  mutex-acquire (chan.write_lock)
  # Clean up
  fifo-fd-destroy (chan.pipe)
  rw-lock-destroy (chan.message_count)
  rw-lock-destroy (chan.will_write)
  mutex-destroy (chan.write_lock)
  mutex-destroy (chan.read_lock)
}
# }}}

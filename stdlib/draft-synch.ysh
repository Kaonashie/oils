#!/usr/bin/env ysh

module stdlib/synch || return 0

#
# FIFO File Descriptors
#

proc fifo-fd-new(; out_fd) {
  # WARN: this section should be critical but for now it's not
  # A solution may be retry on fail.
  #====================
  var fifo = $(mktemp -u)
  mkfifo $fifo
  #====================
  exec {fd}<>$fifo
  call out_fd->setValue(fd)
}

# Tests whether the fd is opened
func fifoFdTest(fd) {
  var fdlink = "/proc/$$/fd/$fd"
  if test -L $fdlink {
    return (true)
  } else {
    return (false)
  }
}

proc fifo-fd-destroy(; fd) {
  if (fifoFdTest(fd)) {
    var fifoFile = $(readlink "/proc/$$/fd/$fd")
    # NOTE: No need to close both end of a pipe.
    exec {fd}>&-
    rm $fifoFile
  } else {
    echo "Double Destroying the fd $fd twice!" 1>&2
    exit 1
  }
}

#
# Semaphores
#

proc sema-new(; value, out_sema) {
  fifo-fd-new (&sema)
  sema-up (sema, value)
  call out_sema->setValue(sema)
}

proc sema-down(; sema) {
  read <&$sema
}

proc sema-up(; sema, delta = 1) {
  fork {
    for _ in (0 .. delta) {
      echo >&$sema
    }
  }
}

proc sema-destroy(; sema) {
  fifo-fd-destroy (sema)
}

#
# Mutex
#

proc mutex-new(; out_mutex) {
  sema-new (1, out_mutex)
} 

proc mutex-acquire(; mutex) {
  sema-down (mutex)
}

proc mutex-release(; mutex) {
  sema-up (mutex)
}

proc mutex-destroy(; mutex) {
  sema-destroy (mutex)
}

#
# Channels
# - Pipeline but you can send multiple objects across pipelines
# - Has to manually ensure the number of sent/received blocks are same across each side.
# - Blocks, no buffering

const ZERO_CHAR = u'\u{0}'

proc channel-new(; out_chan) {
  mutex-new (&write_lock)
  mutex-new (&read_lock)
  fifo-fd-new (&pipe)
  call out_chan->setValue({
    write_lock,
    read_lock,
    pipe,
  })
}

proc channel-in(; chan) {
  var data = $(cat) # consume everything from input
  var data_len = len(data)
  mutex-acquire (chan.write_lock)
  write -n ${data_len}${ZERO_CHAR}${data} >&$[chan.pipe]
  mutex-release (chan.write_lock)
}

proc channel-out(; chan) {
  var data_len = ""
  mutex-acquire (chan.read_lock)
  while (true) {
    read -n 1 next_char <&$[chan.pipe]
    if (next_char !== ZERO_CHAR) {
      setvar data_len = data_len ++ next_char
    } else {
      break
    }
  }
  read -n $data_len chunk <&$[chan.pipe]
  write -n $chunk
  mutex-release (chan.read_lock)
}

proc channel-destroy(; chan) {
  fifo-fd-destroy (chan.pipe)
  mutex-destroy (chan.read_lock)
  mutex-destroy (chan.write_lock)
}

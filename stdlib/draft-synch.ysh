#!/usr/bin/env ysh
# vim:foldmethod=marker

module stdlib/synch || return 0

# General utilities for fds {{{

# Tests whether the fd is opened
func fdTest(fd) {
  var fdlink = "/proc/$$/fd/$fd"
  if test -L $fdlink {
    return (true)
  } else {
    return (false)
  }
}

proc fd-destroy(; fd) {
  if (fdTest(fd)) {
    var fifoFile = $(readlink "/proc/$$/fd/$fd")
    # NOTE: No need to close both end of a pipe.
    exec {fd}>&-
    rm $fifoFile
  } else {
    echo "Double Destroying the fd $fd twice!" 1>&2
    exit 1
  }
}
# }}}
# FIFO File Descriptors {{{

proc fifo-fd-new(; out_fd) {
  # WARN: this section should be critical but for now it's not
  # A solution may be retry on fail.
  #====================
  var fifo = $(mktemp -u)
  mkfifo $fifo
  #====================
  exec {fd}<>$fifo
  call out_fd->setValue(fd)
}

proc fifo-fd-destroy (; fd) {
  fd-destroy (fd)
}

# }}}
# Semaphores {{{

proc sema-new(; value, out_sema) {
  fifo-fd-new (&sema)
  sema-up (sema, value)
  call out_sema->setValue(sema)
}

proc sema-down(; sema) {
  read <&$sema
}

proc sema-up(; sema, delta = 1) {
  fork {
    for _ in (0 .. delta) {
      echo >&$sema
    }
  }
}

proc sema-destroy(; sema) {
  fifo-fd-destroy (sema)
}

# }}}
# Mutex {{{

proc mutex-new(; out_mutex) {
  sema-new (1, out_mutex)
} 

proc mutex-acquire(; mutex) {
  sema-down (mutex)
}

proc mutex-release(; mutex) {
  sema-up (mutex)
}

proc mutex-destroy(; mutex) {
  sema-destroy (mutex)
}

# }}}
# Channels {{{
# - Pipeline but you can send multiple objects across pipelines
# - Has to manually ensure the number of sent/received blocks are same across each side.
# - Blocks, no buffering

const ZERO_CHAR = u'\u{0}'

proc channel-new(; out_chan) {
  mutex-new (&write_lock)
  mutex-new (&read_lock)
  fifo-fd-new (&pipe)
  call out_chan->setValue({
    write_lock,
    read_lock,
    pipe,
  })
}

proc channel-in(; chan) {
  var msg = $(cat) # consume everything from input
  var msg_len = len(msg)
  mutex-acquire (chan.write_lock)
  write -n ${msg_len}${ZERO_CHAR}${msg} >&$[chan.pipe]
  mutex-release (chan.write_lock)
}

proc channel-out(; chan) {
  var msg_len = ""
  mutex-acquire (chan.read_lock)
  while (true) {
    read -n 1 next_char <&$[chan.pipe]
    if (next_char !== ZERO_CHAR) {
      setvar msg_len = msg_len ++ next_char
    } else {
      break
    }
  }
  read -n $msg_len chunk <&$[chan.pipe]
  write -n $chunk
  mutex-release (chan.read_lock)
}

proc channel-destroy(; chan) {
  # Ensures no one else is working
  mutex-acquire (chan.read_lock)
  mutex-acquire (chan.write_lock)
  # Clean up
  fifo-fd-destroy (chan.pipe)
  mutex-destroy (chan.write_lock)
  mutex-destroy (chan.read_lock)
}

# }}}
# RWLock {{{

proc rw-lock-new(; out_lock) {
  var lockfile = $(mktemp)
  var lock = {
    fd: null,
    lockfile,
  }
  call out_lock->setValue(lock)
}

proc rw-lock-read-out(; lock) {
  # TODO: ensure we're actually holding the shared/exclusive lock
  cat $[lock.lockfile]
}

proc rw-lock-write-in(; lock) {
  # TODO: ensure we're actually holding the exclusive lock
  cat > $[lock.lockfile]
}

# NOTE: to change the type of a lock to T, e.g. from shared to exclusive, just call rw-lock-{T} again. 
proc rw-lock-shared(; lock) {
  if (lock.fd === null) {
    exec {lock_fd}<$[lock.lockfile]
    setvar lock.fd = lock_fd
  }
  flock -s $[lock.fd]
}

proc rw-lock-exclusive(; lock) {
  if (lock.fd === null) {
    exec {lock_fd}<>$[lock.lockfile]
    setvar lock.fd = lock_fd
  }
  flock -x $[lock.fd]
}

proc rw-unlock(; lock) {
  if (lock.fd === null) {
    echo "not locked"
    exit 1
  }
  flock -u $[lock.fd]
}

# Performs an lock-guarded write on a lock's file
proc rw-lock-swap-pipe(; lock) {
  rw-lock-exclusive (lock)
  rw-lock-read-out (lock)
  rw-lock-write-in (lock)
  rw-unlock (lock)
}

proc rw-lock-destroy(; lock) {
  if (lock.fd !== null) {
    fd-destroy (lock.fd)
  } else {
    rm $[lock.lockfile]
  }
}

# }}}
# Exhaustable Channels {{{
# Channels but exhaustable

proc exh-channel-new(; out_chan) {
  mutex-new (&write_lock)
  mutex-new (&read_lock)
  fifo-fd-new (&pipe)
  # a counter on how many information we have on the pipe
  rw-lock-new (&message_count)
  # a lock indicating if there's upcoming writes
  rw-lock-new (&will_write)
  rw-lock-exclusive (message_count)
  write -n 0 | rw-lock-write-in (message_count)
  rw-unlock (message_count)
  call out_chan->setValue({
    write_lock,
    read_lock,
    pipe,
    message_count,
    will_write,
  })
}

proc exh-channel-in(; chan) {
  var msg = $(cat) # consume everything from input
  var msg_len = len(msg)
  # NOTE: the below can be abstracted out to a 2-direction pipe
  # This is a pretty common pattern in bash.
  # However there's no way to refer to a proc for now
  #################################################
  fifo-fd-new (&fd)
  rw-lock-swap-pipe (chan.message_count) <&$fd | {
    var cnt
    json read (&cnt)
    setvar cnt += 1
    echo $cnt
  } >&$fd
  fifo-fd-destroy (fd)
  #################################################
  rw-lock-shared (chan.will_write)
  mutex-acquire (chan.write_lock)
  write -n $msg_len$ZERO_CHAR$msg >&$[chan.pipe]
  mutex-release (chan.write_lock)
  rw-unlock (chan.will_write)
}

proc exh-channel-out(; chan) {
  var msg_len = ""
  mutex-acquire (chan.read_lock)
  while (true) {
    read -n 1 next_char <&$[chan.pipe]
    if (next_char !== ZERO_CHAR) {
      setvar msg_len = msg_len ++ next_char
    } else {
      break
    }
  }
  read -n $msg_len chunk <&$[chan.pipe]
  write -n $chunk
  mutex-release (chan.read_lock)
}

proc exh-channel-exhaust(; chan, out_ret) {
  var ret = []
  rw-lock-exclusive (chan.will_write)
  rw-lock-read-out (chan.message_count) | json read (&num_msg)

  for _ in (0..num_msg) {
    call ret->append($(exh-channel-out))
  }
  rw-unlock (chan.will_write)
  call out_ret->setValue(ret)
}

proc exh-channel-destroy(; chan) {
  # Ensures no one else is working
  mutex-acquire (chan.read_lock)
  mutex-acquire (chan.write_lock)
  rw-lock-exclusive (chan.exhaust_lock)
  rw-lock-exclusive (chan.message_count)
  # Clean up
  fifo-fd-destroy (chan.pipe)
  rw-lock-destroy (chan.message_count)
  rw-lock-destroy (chan.exhaust_lock)
  mutex-destroy (chan.write_lock)
  mutex-destroy (chan.read_lock)
}
# }}}

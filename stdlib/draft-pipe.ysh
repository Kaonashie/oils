module stdlib/pipe || return 0

# NOTE: I would love to optimize this a bit more, for example netstring of size n 
# now takes log_10(n) over head. We can certainly do this better by byte encoding
# It would be log_128(n) (using 1 bit for indicating the number ends)
# That's a ln 128 / ln 10 which is roughly twice less overhead.
proc netstring-pipe-in () {
  var msg = $(cat) # consume everything from input
  write -n $[len(msg)]${ZERO_CHAR}${msg}
}

proc netstring-pipe-out() {
  var msg_len = ""
  while (true) {
    read -n 1 next_char
    if (next_char !== ZERO_CHAR) {
      setvar msg_len = msg_len ++ next_char
    } else {
      break
    }
  }
  read -n $msg_len chunk
  write -n $chunk
}

# NOTE: No way to refer to procs, I wrap them around funcs for now.
func __pipe_netstring_pipe_in_wrap() {
  netstring-pipe-in
}
func __pipe_netstring_pipe_out_wrap() {
  netstring-pipe-out
}
const Pipe_Methods_NetString = {
  in_pipe: __pipe_netstring_pipe_in_wrap,
  out_pipe: __pipe_netstring_pipe_out_wrap,
}

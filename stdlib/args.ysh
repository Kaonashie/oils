# args.ysh
#
# Usage:
#   source --builtin args.sh
#
# Args :spec {
#   flag -v --verbose "Verbosely"  # default is Bool, false
#
#   flag -P --max-procs '''
#     Run at most P processes at a time
#     ''' (Int, default=-1)
#
#   flag -i --invert '''
#     Long multiline
#     Description
#     ''' (Bool, default = true)
#
#   arg src 'Source'
#   arg src 'Dest'
#   arg times 'Foo' (Int)
# }
#
# var opt, i = parseArgs(spec, ARGV)
#
# echo "Verbose $[opt.verbose]"

# TODO: See list
# - It would be nice to keep `flag` and `arg` private, injecting them into the
#   proc namespace only within `Args`
# - We need a mechanism to share state between Args and `flag`/`arg` that is
#   run in the block passed to it
#   - It would be nice if _this was a magic param?
#     - it would be nice if 'flag' was a "method" on something?
#     - that's what it's doing, it's mutating "self"
#     - _this is the thing we're currently creating

proc arg-parse (; place ; ; block_def) {
  ## Create an args spec which can be passed to parseArgs.
  ##
  ## Example:
  ##
  ##   # NOTE: &spec will create a variable named spec
  ##   arg-parse (&spec) {
  ##     flag -v --verbose ('bool')
  ##   }
  ##
  ##   var flag, i = parseArgs(spec, ARGV)

  var p = {}
  ctx push (p) {
    flag -h --help (help="Show this help message and exit", default=false)
    eval (block_def)
  }

  # Validate that p.rest = [name] or null and reduce p.rest into name or null.
  if ('rest' in p) {
    if (len(p.rest) > 1) {
      error '`rest` was called more than once' (status=3)
    } else {
      setvar p.rest = p.rest[0]
    }
  } else {
    setvar p.rest = null
  }

  call place->setValue(p)
}

proc flag (short, long ; type='bool' ; default=null, help=null) {
  ## Declare a flag within an `arg-parse`.
  ##
  ## Examples:
  ##
  ##   arg-parse (&spec) {
  ##     flag -v --verbose
  ##     flag -n --count ('int', default=1)
  ##     flag -f --file ('str', help="File to process")
  ##   }

  # TODO: type objects (ie. Bool, Int, Str)
  ctx emit flags ({short, long, type, default, help})
}

proc arg (name ; ; default=null, help=null) {
  ## Declare a positional argument within an `arg-parse`.
  ##
  ## Examples:
  ##
  ##   arg-parse (&spec) {
  ##     arg name
  ##     arg config (help="config file path")
  ##     arg out (default="a.out", help="output file path")
  ##   }

  ctx emit args ({name, default, help})
}

proc rest (name) {
  ## Take the remaining positional arguments within an `arg-parse`.
  ##
  ## Examples:
  ##
  ##   arg-parse (&grepSpec) {
  ##     arg query
  ##     rest files
  ##   }

  # We emit instead of set to detect multiple invocations of "rest"
  ctx emit rest (name)
}

proc prog-name (progName) {
  ## Set the program name used when displaying program usage and the generated
  ## help message. (If this is not set, $0 is used instead.)

  ctx set (name=progName)
}

proc description (description) {
  ## Annotate an argument spec with a description displayed in the generated
  ## help message.

  ctx set (description=description)
}

func __args_getFlagName(flag) {
  if (flag.long) {
    return (flag.long[2:])
  } elif (flag.short) {
    return (flag.short[1:])
  }

  error ('No flag.long or flag.short')
}

proc print-help (; spec) {
  var name = "$0"
  if ('name' in spec) {
    setvar name = spec.name
  }

  var flags = []
  for flag in (spec.flags) {
    if (flag.default === null) {
      # required (no [..])
      call flags->append(" $[flag.short]")
    } else {
      # optional (add [..])
      call flags->append(" [$[flag.short]]")
    }
  }

  var args = []
  for arg in (spec.args) {
    call args->append(" $[arg.name]")
  }

  var rest = ''
  if ('rest' in spec and spec.rest) {
    setvar rest = " ...$[spec.rest[0]]"
  }

  setvar flags = flags => join("")
  setvar args = args => join("")

  write "usage: $name$flags$args$rest"
  write
  write $[spec.description]

  write 'Positional Arguments:'
  for arg in (spec.args) {
    write " $[arg.name]"
  }
  write

  write 'Flags:'
  for flag in (spec.flags) {
    write -n -- " $[flag.short], $[flag.long]"

    if ('help' in flag and flag.help) {
      write -n -- u'\t\t'
      write -n -- $[flag.help]
    }

    write
  }
}

func parseArgs(spec, argv) {
  ## Given a spec created by `arg-parse`. Parse an array of strings `argv` per
  ## that spec.
  ##
  ## See `arg-parse` for examples of use.

  var i = 0
  var positionalPos = 0
  var argc = len(argv)
  var args = {}
  var rest = []

  var value
  while (i < argc) {
    var arg = argv[i]
    if (arg->startsWith('-')) {
      for flag in (spec.flags) {
        if ( (flag.short and flag.short === arg) or
             (flag.long and flag.long === arg) ) {
          case (flag.type) {
            ('bool') | (null) { setvar value = true }
            int {
              setvar i += 1
              setvar value = int(argv[i])
            }
          }

          var name = __args_getFlagName(flag)
          setvar args[name] = value
        }
      }
    } elif (positionalPos >= len(spec.args)) {
      if (not spec.rest) {
        error ("Too many arguments, unexpected '$arg'")
      }

      call rest->append(arg)
    } else {
      var pos = spec.args[positionalPos]
      setvar positionalPos += 1
      setvar value = arg
      setvar args[pos.name] = value
    }

    setvar i += 1
  }

  if (spec.rest) {
    setvar args[spec.rest] = rest
  }

  if ('help' in args and args.help) {
    print-help (spec)

    exit 0
  }

  return ([args, i])
}
